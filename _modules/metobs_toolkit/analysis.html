<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>metobs_toolkit.analysis &mdash; metobs_toolkit 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >

          
          
          <a href="../../index.html" class="icon icon-home">
            metobs_toolkit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../template_mapping.html">Mapping to the toolkit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gee_authentication.html">Using Google Earth Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../special_topics.html">Special topics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gui.html">Using the GUI</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MetObs_documentation.html">MetObs toolkit Documentation for Users</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../MetObs_documentation_full.html">MetObs toolkit Documentation for developers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: white" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">metobs_toolkit</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">metobs_toolkit.analysis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for metobs_toolkit.analysis</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the Analysis class and all its methods.</span>

<span class="sd">A Analysis holds a set of &#39;good&#39; observations and the methods will analyse them.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">pearsonr</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.plotting_functions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">diurnal_plot</span><span class="p">,</span>
                                               <span class="n">heatmap_plot</span><span class="p">,</span>
                                               <span class="n">correlation_scatter</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.df_helpers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">init_multiindexdf</span><span class="p">,</span>
                                        <span class="n">datetime_subsetting</span><span class="p">,</span>
                                        <span class="n">subset_stations</span><span class="p">)</span>

<div class="viewcode-block" id="Analysis"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis">[docs]</a><span class="k">class</span> <span class="nc">Analysis</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The Analysis class contains methods for analysing diurnal cycles and landcover effects&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obsdf</span><span class="p">,</span> <span class="n">metadf</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">data_template</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">metadf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span> <span class="o">=</span> <span class="n">data_template</span>

        <span class="c1"># analysis objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lc_cor_obstype</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Empty Analysis instance.&quot;</span>
        <span class="n">add_info</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">n_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_obs_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">startdt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lon&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">())):</span>
            <span class="n">add_info</span> <span class="o">+=</span> <span class="s1">&#39;     *Coordinates are available for all stations. </span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="n">add_info</span> <span class="o">+=</span> <span class="s2">&quot;     *LCZ&#39;s are available for all stations. </span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="p">):</span>
            <span class="n">add_info</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;     *landcover correlations are computed on group: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span><span class="si">}</span><span class="s2">  </span><span class="se">\n</span><span class="s2">&quot;</span>




        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analysis instance containing: </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="n">n_stations</span><span class="si">}</span><span class="s2"> stations </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span><span class="si">}</span><span class="s2"> observation types </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="n">n_obs_tot</span><span class="si">}</span><span class="s2"> observation records </span><span class="se">\n</span><span class="si">{</span><span class="n">add_info</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *records range: </span><span class="si">{</span><span class="n">startdt</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">enddt</span><span class="si">}</span><span class="s2"> (total duration:  </span><span class="si">{</span><span class="n">enddt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startdt</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="o">+</span> <span class="n">add_info</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="c1"># =============================================================================</span>
    <span class="c1">#     Setters</span>
    <span class="c1"># =============================================================================</span>


<div class="viewcode-block" id="Analysis.subset_period"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.subset_period">[docs]</a>    <span class="k">def</span> <span class="nf">subset_period</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startdt</span><span class="p">,</span> <span class="n">enddt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subset the observations of the Analysis to a specific period. The same</span>
<span class="sd">        timezone is assumed as the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        startdt : datetime.datetime</span>
<span class="sd">            The start datetime to filter the observations to.</span>
<span class="sd">        enddt : datetime.datetime</span>
<span class="sd">            The end datetime to filter the observations to.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">startdt</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">startdt</span><span class="si">}</span><span class="s1"> not a datetime type. Ignore subsetting!&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enddt</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">enddt</span><span class="si">}</span><span class="s1"> not a datetime type. Ignore subsetting!&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">datetime_subsetting</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">startdt</span><span class="p">,</span> <span class="n">enddt</span><span class="p">)</span></div>

    <span class="c1"># =============================================================================</span>
    <span class="c1">#   Helpers</span>
    <span class="c1"># =============================================================================</span>


<div class="viewcode-block" id="Analysis.apply_filter"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.apply_filter">[docs]</a>    <span class="k">def</span> <span class="nf">apply_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to filter an Analysis by a user definde string expression. This</span>
<span class="sd">        can be used to filter the observation to specific meteorological conditions</span>
<span class="sd">        (i.e. low windspeeds, high humidity, cold temperatures, ...)</span>

<span class="sd">        The filter expression contains only columns present in the Analysis.df</span>
<span class="sd">        and/or the Analysis.metadf.</span>

<span class="sd">        A New Analysis object is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        expression : str</span>
<span class="sd">            A filter expression using columnnames present in either df or metadf.</span>
<span class="sd">            The following timestamp derivatives can be used as well: [minute, hour,</span>
<span class="sd">            month, year, day_of_year, week_of_year, season]. The quarry_str may</span>
<span class="sd">            contain number and expressions like &lt;, &gt;, ==, &gt;=, *, +, .... Multiple filters</span>
<span class="sd">            can be combine to one expression by using &amp; (AND) and | (OR).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filtered_analysis : metobs_toolkit.Analysis</span>
<span class="sd">            The filtered Analysis.</span>


<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        All timestamp derivative values are numeric except for &#39;season&#39;,</span>
<span class="sd">        possible values are [&#39;winter&#39;, &#39;spring&#39;, &#39;summer&#39;, &#39;autumn&#39;].</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        Make shure to use &quot; of &#39; to indicate string values in the expression if</span>
<span class="sd">        needed.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">child_df</span><span class="p">,</span> <span class="n">child_metadf</span> <span class="o">=</span> <span class="n">filter_data</span><span class="p">(</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                                             <span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
                                             <span class="n">quarry_str</span> <span class="o">=</span> <span class="n">expression</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Analysis</span><span class="p">(</span><span class="n">obsdf</span><span class="o">=</span><span class="n">child_df</span><span class="p">,</span>
                        <span class="n">metadf</span> <span class="o">=</span> <span class="n">child_metadf</span><span class="p">,</span>
                        <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                        <span class="n">data_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">)</span></div>




<div class="viewcode-block" id="Analysis.aggregate_df"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.aggregate_df">[docs]</a>    <span class="k">def</span> <span class="nf">aggregate_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">agg</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregate observations to a (list of) categories.</span>

<span class="sd">        The output will be a dataframe that is aggregated to one, or more categories.</span>
<span class="sd">        A commen example is aggregating to LCZ&#39;s.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.DataFrame or None</span>
<span class="sd">            The observations to aggregate. If None, the df attribute of the</span>
<span class="sd">            Analysis instance is used. The default is None.</span>
<span class="sd">        agg : list, optional</span>
<span class="sd">            The list of columnnames to aggregate to. If &#39;lcz&#39; is included, the</span>
<span class="sd">            lcz information is extracted from the Analysis.metadf. The default is [&#39;lcz&#39;, &#39;datetime&#39;].</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            list of functions and/or function names, e.g. [np.sum, &#39;mean&#39;]. The default is &#39;mean&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A dataframe with the agg columns as an index. The values are the aggregated values.</span>

<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        Present columns that ar non-numeric and are not in the agg list, are</span>
<span class="sd">        not present in the return, since these values cannot be aggregated.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="n">time_agg_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">,</span> <span class="s1">&#39;month&#39;</span><span class="p">,</span> <span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="s1">&#39;day_of_year&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;week_of_year&#39;</span><span class="p">,</span> <span class="s1">&#39;season&#39;</span><span class="p">]</span>

        <span class="c1"># scan trough the metadf for aggregation keys</span>
        <span class="k">for</span> <span class="n">agg_key</span> <span class="ow">in</span> <span class="n">agg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">agg_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># look in metadf</span>
                <span class="k">if</span> <span class="n">agg_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[[</span><span class="n">agg_key</span><span class="p">]],</span>
                                      <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>
                                      <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>




        <span class="c1"># Check if all agg keys are present or defined:</span>
        <span class="n">possible_agg_keys</span> <span class="o">=</span> <span class="n">time_agg_keys</span>
        <span class="n">possible_agg_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
        <span class="n">unmapped</span> <span class="o">=</span> <span class="p">[</span><span class="n">agg_key</span> <span class="k">for</span> <span class="n">agg_key</span> <span class="ow">in</span> <span class="n">agg</span> <span class="k">if</span> <span class="n">agg_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_agg_keys</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmapped</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;cannot aggregate to unknown labels: </span><span class="si">{</span><span class="n">unmapped</span><span class="si">}</span><span class="s1">.&#39;</span>


        <span class="c1"># make time-derivate columns if required</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_make_time_derivatives</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">agg</span><span class="p">)</span>


        <span class="c1"># check if not all values are Nan</span>
        <span class="k">for</span> <span class="n">agg_name</span> <span class="ow">in</span> <span class="n">agg</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">df</span><span class="p">[</span><span class="n">agg_name</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Aggregation to </span><span class="si">{</span><span class="n">agg_name</span><span class="si">}</span><span class="s1"> not possible because no valid values found for </span><span class="si">{</span><span class="n">agg_name</span><span class="si">}</span><span class="s1">.&#39;</span>



        <span class="c1"># Aggregate the df</span>
        <span class="n">agg_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># sort index</span>
        <span class="n">agg_df</span> <span class="o">=</span> <span class="n">agg_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">agg_df</span> <span class="o">=</span> <span class="n">agg_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">agg_df</span></div>


    <span class="c1"># =============================================================================</span>
    <span class="c1">#   Analyse method</span>
    <span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="Analysis.get_diurnal_statistics"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.get_diurnal_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">get_diurnal_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">startdt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enddt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">colorby</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">errorbands</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an average diurnal cycle for the observations.</span>

<span class="sd">        (In the plot, each station is represed by a line.)</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            Element of the metobs_toolkit.observation_types The default is &#39;temp&#39;.</span>
<span class="sd">        stations : list, optional</span>
<span class="sd">            List of station names to use. If None, all present stations will be used. The default is None.</span>
<span class="sd">        startdt : datetime.datetime, optional</span>
<span class="sd">            The start datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        enddt : datetime.datetime, optional</span>
<span class="sd">            The end datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            If True, a diurnal plot is made. The default is True.</span>
<span class="sd">        title : string, optional</span>
<span class="sd">             Title of the figure, if None a default title is generated. The default is None.</span>
<span class="sd">        y_label : string, optional</span>
<span class="sd">             y-axes label of the figure, if None a default label is generated. The default is None.</span>
<span class="sd">        legend : bool, optional</span>
<span class="sd">             I True, a legend is added to the plot. The default is True.</span>
<span class="sd">        colorby : &#39;name&#39; or &#39;lcz&#39;, optional</span>
<span class="sd">            If &#39;name&#39; the plotted lines will be colored per station, if &#39;lcz&#39; the colors represent the stations lcz. The default is &#39;name&#39;.</span>
<span class="sd">        errorbands : bool, optional</span>
<span class="sd">            If True, the std is representd in the plot by colored bands. The default is False.</span>
<span class="sd">        verbose : True, optional</span>
<span class="sd">            If True, the dataframse with aggregation information are returned . The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple (if verbose)</span>
<span class="sd">            A tuple of dataframes is returned when verbose is True.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="c1"># Filter stations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">stations</span> <span class="o">=</span> <span class="p">[</span><span class="n">stations</span><span class="p">]</span>

            <span class="n">obsdf</span> <span class="o">=</span> <span class="n">subset_stations</span><span class="p">(</span><span class="n">obsdf</span><span class="p">,</span> <span class="n">stations</span><span class="p">)</span>

        <span class="c1"># Filter datetimes</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">datetime_subsetting</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">obsdf</span><span class="p">,</span>
                                    <span class="n">starttime</span><span class="o">=</span><span class="n">startdt</span><span class="p">,</span>
                                    <span class="n">endtime</span><span class="o">=</span><span class="n">enddt</span><span class="p">)</span>

        <span class="c1"># check if lcz is available if required</span>
        <span class="k">if</span> <span class="n">colorby</span> <span class="o">==</span> <span class="s1">&#39;lcz&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: Not all stations have a LCZ. Update the LCZ&#39;s first or use colorby=&#39;name&#39;. &quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>



        <span class="c1"># Get hours for all records</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">obsdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>


        <span class="n">agg_column_name</span> <span class="o">=</span> <span class="n">obstype</span> <span class="c1">#aggregate the measured obstypes</span>
        <span class="n">startdt</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


        <span class="c1"># groupby and take the mean per station per hour.</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">obsdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">])[</span><span class="n">agg_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">])</span>

        <span class="n">hourly_avg</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># get lcz groups if needed</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">colorby</span> <span class="o">==</span> <span class="s1">&#39;lcz&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="s1">&#39;lcz&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: No LCZ information, thus colorby will be set to name.&#39;</span><span class="p">)</span>
                <span class="n">colorby</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>
            <span class="k">if</span> <span class="n">colorby</span> <span class="o">==</span><span class="s1">&#39;lcz&#39;</span><span class="p">:</span>
                <span class="n">lcz_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">][</span><span class="n">hourly_avg</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcz_dict</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># generate title</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startdtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">startdt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>
                <span class="n">enddtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">enddt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>

                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Hourly average </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s1"> diurnal cycle for period </span><span class="si">{</span><span class="n">startdtstr</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">enddtstr</span><span class="si">}</span><span class="s1">&#39;</span>


            <span class="c1"># generate errorbands df</span>
            <span class="k">if</span> <span class="n">errorbands</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># extract timezone</span>
            <span class="n">tzstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">zone</span>


            <span class="c1"># Make plot</span>
            <span class="n">diurnal_plot</span><span class="p">(</span><span class="n">diurnaldf</span> <span class="o">=</span> <span class="n">hourly_avg</span><span class="p">,</span>
                         <span class="n">errorbandsdf</span> <span class="o">=</span> <span class="n">stddf</span><span class="p">,</span>
                         <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="p">,</span>
                         <span class="n">tzstr</span><span class="o">=</span><span class="n">tzstring</span><span class="p">,</span>
                         <span class="n">plot_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s1">&#39;plot_settings&#39;</span><span class="p">][</span><span class="s1">&#39;diurnal&#39;</span><span class="p">],</span>
                         <span class="n">colorby</span> <span class="o">=</span> <span class="n">colorby</span><span class="p">,</span>
                         <span class="n">lcz_dict</span> <span class="o">=</span> <span class="n">lcz_dict</span><span class="p">,</span>
                         <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
                         <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                         <span class="n">y_label</span> <span class="o">=</span> <span class="n">y_label</span><span class="p">,</span>
                         <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hourly_avg</span><span class="p">,</span> <span class="n">stats</span>

        <span class="k">return</span> <span class="n">hourly_avg</span></div>

<div class="viewcode-block" id="Analysis.get_diurnal_statistics_with_reference"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.get_diurnal_statistics_with_reference">[docs]</a>    <span class="k">def</span> <span class="nf">get_diurnal_statistics_with_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refstation</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span>
                                              <span class="n">tollerance</span><span class="o">=</span><span class="s1">&#39;30T&#39;</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                              <span class="n">startdt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enddt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                              <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                              <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                              <span class="n">colorby</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">errorbands</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an average diurnal cycle for the observation differences of a reference station.</span>

<span class="sd">        All observational values are converted to differences with the closest</span>
<span class="sd">        (in time) reference observation. No reference observation is found when</span>
<span class="sd">        the time difference is larger than the tollerance.</span>

<span class="sd">        (In the plot, each station is represed by a line.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        refstation : str,</span>
<span class="sd">            Name of the station to use as a reference.</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            Element of the metobs_toolkit.observation_types The default is &#39;temp&#39;.</span>
<span class="sd">        tollerance : Timedelta or str, optional</span>
<span class="sd">            The tollerance string or object representing the maximum translation in time to find a reference</span>
<span class="sd">            observation for each observation. Ex: &#39;5T&#39; is 5 minuts, &#39;1H&#39;, is one hour. The default is &#39;30T&#39;.</span>
<span class="sd">        stations : list, optional</span>
<span class="sd">            List of station names to use. If None, all present stations will be used. The default is None.</span>
<span class="sd">        startdt : datetime.datetime, optional</span>
<span class="sd">            The start datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        enddt : datetime.datetime, optional</span>
<span class="sd">            The end datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            If True, a diurnal plot is made. The default is True.</span>
<span class="sd">        title : string, optional</span>
<span class="sd">             Title of the figure, if None a default title is generated. The default is None.</span>
<span class="sd">        y_label : string, optional</span>
<span class="sd">             y-axes label of the figure, if None a default label is generated. The default is None.</span>
<span class="sd">        legend : bool, optional</span>
<span class="sd">             I True, a legend is added to the plot. The default is True.</span>
<span class="sd">        colorby : &#39;name&#39; or &#39;lcz&#39;, optional</span>
<span class="sd">            If &#39;name&#39; the plotted lines will be colored per station, if &#39;lcz&#39; the colors represent the stations lcz. The default is &#39;name&#39;.</span>
<span class="sd">        errorbands : bool, optional</span>
<span class="sd">            If True, the std is representd in the plot by colored bands. The upper bound represents +1 x std, the lower bound -1 x std. The default is False.</span>
<span class="sd">        verbose : True, optional</span>
<span class="sd">            If True, the dataframse with aggregation information are returned . The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple (if verbose)</span>
<span class="sd">            A tuple of dataframes is returned when verbose is True.</span>

<span class="sd">        &quot;&quot;&quot;</span>




        <span class="n">obsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="c1"># Filter stations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">stations</span> <span class="o">=</span> <span class="p">[</span><span class="n">stations</span><span class="p">]</span>
                <span class="n">stations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">refstation</span><span class="p">)</span>
            <span class="n">obsdf</span> <span class="o">=</span> <span class="n">subset_stations</span><span class="p">(</span><span class="n">obsdf</span><span class="p">,</span> <span class="n">stations</span><span class="p">)</span>


        <span class="c1"># Filter datetimes</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">datetime_subsetting</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">obsdf</span><span class="p">,</span>
                                    <span class="n">starttime</span><span class="o">=</span><span class="n">startdt</span><span class="p">,</span>
                                    <span class="n">endtime</span><span class="o">=</span><span class="n">enddt</span><span class="p">)</span>

        <span class="c1"># check if lcz is available if required</span>
        <span class="k">if</span> <span class="n">colorby</span> <span class="o">==</span> <span class="s1">&#39;lcz&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: Not all stations have a LCZ. Update the LCZ&#39;s first or use colorby=&#39;name&#39;. &quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>



        <span class="c1"># extract refernce from observations</span>
        <span class="n">refdf</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">refstation</span><span class="p">]</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">!=</span> <span class="n">refstation</span><span class="p">]</span>

        <span class="c1"># Syncronize observations with the reference observations</span>
        <span class="n">refdf</span> <span class="o">=</span> <span class="n">refdf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">obstype</span><span class="p">:</span> <span class="s1">&#39;ref_&#39;</span><span class="o">+</span><span class="n">obstype</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">:</span> <span class="s1">&#39;ref_datetime&#39;</span><span class="p">})</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">obsdf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">),</span>
                                <span class="n">right</span><span class="o">=</span><span class="n">refdf</span><span class="p">[[</span><span class="s1">&#39;ref_datetime&#39;</span><span class="p">,</span> <span class="s1">&#39;ref_&#39;</span><span class="o">+</span><span class="n">obstype</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;ref_datetime&#39;</span><span class="p">),</span>
                                <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;ref_datetime&quot;</span><span class="p">,</span>
                                <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;datetime&quot;</span><span class="p">,</span>
                                <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                                <span class="n">tolerance</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">tollerance</span><span class="p">),</span>
                                <span class="p">)</span>

        <span class="n">startdt</span> <span class="o">=</span> <span class="n">refdf</span><span class="p">[</span><span class="s1">&#39;ref_datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="n">refdf</span><span class="p">[</span><span class="s1">&#39;ref_datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="c1"># Compute difference</span>
        <span class="n">agg_column_name</span> <span class="o">=</span> <span class="s1">&#39;difference&#39;</span>
        <span class="n">mergedf</span><span class="p">[</span><span class="n">agg_column_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span> <span class="o">-</span> <span class="n">mergedf</span><span class="p">[</span><span class="s1">&#39;ref_&#39;</span><span class="o">+</span><span class="n">obstype</span><span class="p">]</span>

        <span class="c1"># Get hour column</span>
        <span class="n">mergedf</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>

        <span class="c1"># overwrite the obsdf</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">mergedf</span>
        <span class="c1"># groupby and take the mean per station per hour.</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">obsdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">])[</span><span class="n">agg_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">])</span>

        <span class="n">hourly_avg</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>


        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="c1"># get lcz groups if needed</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">colorby</span> <span class="o">==</span> <span class="s1">&#39;lcz&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="s1">&#39;lcz&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: No LCZ information, thus colorby will be set to name.&#39;</span><span class="p">)</span>
                <span class="n">colorby</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span>

            <span class="k">if</span> <span class="n">colorby</span> <span class="o">==</span><span class="s1">&#39;lcz&#39;</span><span class="p">:</span>
                <span class="n">lcz_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">][</span><span class="n">hourly_avg</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lcz_dict</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># generate title</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startdtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">startdt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>
                <span class="n">enddtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">enddt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>
                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Hourly average </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s1"> diurnal cycle, with </span><span class="si">{</span><span class="n">refstation</span><span class="si">}</span><span class="s1"> as reference, for period </span><span class="si">{</span><span class="n">startdtstr</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">enddtstr</span><span class="si">}</span><span class="s1">&#39;</span>


            <span class="c1"># generate errorbands df</span>
            <span class="k">if</span> <span class="n">errorbands</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># extract timezone</span>
            <span class="n">tzstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">zone</span>


            <span class="c1"># Make plot</span>
            <span class="n">diurnal_plot</span><span class="p">(</span><span class="n">diurnaldf</span> <span class="o">=</span> <span class="n">hourly_avg</span><span class="p">,</span>
                         <span class="n">errorbandsdf</span> <span class="o">=</span> <span class="n">stddf</span><span class="p">,</span>
                         <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="p">,</span>
                         <span class="n">tzstr</span><span class="o">=</span><span class="n">tzstring</span><span class="p">,</span>
                         <span class="n">plot_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s1">&#39;plot_settings&#39;</span><span class="p">][</span><span class="s1">&#39;diurnal&#39;</span><span class="p">],</span>
                         <span class="n">colorby</span> <span class="o">=</span> <span class="n">colorby</span><span class="p">,</span>
                         <span class="n">lcz_dict</span> <span class="o">=</span> <span class="n">lcz_dict</span><span class="p">,</span>
                         <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
                         <span class="n">obstype</span> <span class="o">=</span> <span class="n">obstype</span><span class="p">,</span>
                         <span class="n">y_label</span> <span class="o">=</span> <span class="n">y_label</span><span class="p">,</span>
                         <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>
                         <span class="n">show_zero_horizontal</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hourly_avg</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">obsdf</span>

        <span class="k">return</span> <span class="n">hourly_avg</span></div>


<div class="viewcode-block" id="Analysis.get_aggregated_diurnal_statistics"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.get_aggregated_diurnal_statistics">[docs]</a>    <span class="k">def</span> <span class="nf">get_aggregated_diurnal_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s1">&#39;temp&#39;</span><span class="p">,</span> <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">aggregation</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lcz&#39;</span><span class="p">,</span> <span class="s1">&#39;datetime&#39;</span><span class="p">],</span>
                                          <span class="n">aggregation_method</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span>
                                          <span class="n">startdt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enddt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                          <span class="n">errorbands</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an average diurnal cycle for an aggregated categorie. A commen</span>
<span class="sd">        example is to aggregate to the LCZ&#39;s, so to get the diurnal cycle per LCZ</span>
<span class="sd">        rather than per station.</span>

<span class="sd">        (In the plot, each aggregated category different from datetime, is represed by a line.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            Element of the metobs_toolkit.observation_types The default is &#39;temp&#39;.</span>
<span class="sd">        stations : list, optional</span>
<span class="sd">            List of station names to use. If None, all present stations will be used. The default is None.</span>
<span class="sd">        aggregation : list, optional</span>
<span class="sd">            List of variables to aggregate to. These variables should either a</span>
<span class="sd">            categorical observation type, a categorical column in the metadf or</span>
<span class="sd">            a time aggregation. All possible time aggreagetions are: [&#39;minute&#39;,</span>
<span class="sd">            &#39;hour&#39;, &#39;month&#39;, &#39;year&#39;, &#39;day_of_year&#39;,</span>
<span class="sd">            &#39;week_of_year&#39;, &#39;season&#39;]. The default is [&#39;lcz&#39;, &#39;datetime&#39;].</span>
<span class="sd">        aggregation_method : str, optional</span>
<span class="sd">            Which (numpy) function is used to aggregate the observations. The default is &#39;mean&#39;.</span>
<span class="sd">        startdt : datetime.datetime, optional</span>
<span class="sd">            The start datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        enddt : datetime.datetime, optional</span>
<span class="sd">            The end datetime of the observations to use. If None, all timestamps will be used. The default is None.</span>
<span class="sd">        plot : bool, optional</span>
<span class="sd">            If True, a diurnal plot is made. The default is True.</span>
<span class="sd">        title : string, optional</span>
<span class="sd">             Title of the figure, if None a default title is generated. The default is None.</span>
<span class="sd">        y_label : string, optional</span>
<span class="sd">             y-axes label of the figure, if None a default label is generated. The default is None.</span>
<span class="sd">        legend : bool, optional</span>
<span class="sd">             I True, a legend is added to the plot. The default is True.</span>
<span class="sd">        errorbands : bool, optional</span>
<span class="sd">            If True, the std is representd in the plot by colored bands. The default is False.</span>
<span class="sd">        verbose : True, optional</span>
<span class="sd">            If True, the dataframse with aggregation information are returned . The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple (if verbose)</span>
<span class="sd">            A tuple of dataframes is returned when verbose is True.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="c1"># Filter stations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">stations</span> <span class="o">=</span> <span class="p">[</span><span class="n">stations</span><span class="p">]</span>

            <span class="n">obsdf</span> <span class="o">=</span> <span class="n">subset_stations</span><span class="p">(</span><span class="n">obsdf</span><span class="p">,</span> <span class="n">stations</span><span class="p">)</span>


        <span class="c1"># Filter datetimes</span>
        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">datetime_subsetting</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">obsdf</span><span class="p">,</span>
                                    <span class="n">starttime</span><span class="o">=</span><span class="n">startdt</span><span class="p">,</span>
                                    <span class="n">endtime</span><span class="o">=</span><span class="n">enddt</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">aggregation</span><span class="p">):</span>
            <span class="c1"># check if datetime is in the aggreagation, otherwise no time component is left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;datetime&#39;</span> <span class="ow">in</span> <span class="n">aggregation</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: To make a diurnal cycle with aggregation, the &quot;datetime&quot; must be in the aggregation list. &quot;datetime&quot; is added to it.&#39;</span><span class="p">)</span>
                <span class="n">aggregation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span>
            <span class="n">obsdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aggregate_df</span><span class="p">(</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">,</span> <span class="n">agg</span><span class="o">=</span><span class="n">aggregation</span><span class="p">,</span>
                                      <span class="n">method</span><span class="o">=</span><span class="n">aggregation_method</span><span class="p">)</span>

        <span class="n">obsdf</span> <span class="o">=</span> <span class="n">obsdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="c1"># Create identifiers to form unique hours</span>
        <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>


        <span class="c1"># aggregation scheme setup</span>
        <span class="n">agg_column_name</span> <span class="o">=</span> <span class="n">obstype</span> <span class="c1">#aggregate the measured obstypes</span>
        <span class="n">groupby_list</span> <span class="o">=</span> <span class="n">aggregation</span>
        <span class="n">groupby_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hour&#39;</span><span class="p">)</span>
        <span class="n">groupby_list</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span>

        <span class="c1"># for plot titles</span>
        <span class="n">startdt</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="n">obsdf</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


        <span class="c1"># groupby and take the mean per station per hour.</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">obsdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby_list</span><span class="p">)[</span><span class="n">agg_column_name</span><span class="p">]</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">])</span>

        <span class="n">hourly_avg</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>

            <span class="c1"># generate title</span>
            <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">startdtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">startdt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>
                <span class="n">enddtstr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">enddt</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;print_fmt_datetime&quot;</span><span class="p">])</span>
                <span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Hourly average </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s1"> diurnal cycle for period </span><span class="si">{</span><span class="n">startdtstr</span><span class="si">}</span><span class="s1"> - </span><span class="si">{</span><span class="n">enddtstr</span><span class="si">}</span><span class="s1"> grouped by </span><span class="si">{</span><span class="n">groupby_list</span><span class="si">}</span><span class="s1">&#39;</span>



            <span class="c1"># generate errorbands df</span>
            <span class="k">if</span> <span class="n">errorbands</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unstack</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stddf</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># extract timezone</span>
            <span class="n">tzstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s1">&#39;datetime&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">tz</span><span class="o">.</span><span class="n">zone</span>


            <span class="c1"># Make plot</span>
            <span class="n">diurnal_plot</span><span class="p">(</span><span class="n">diurnaldf</span> <span class="o">=</span> <span class="n">hourly_avg</span><span class="p">,</span>
                         <span class="n">errorbandsdf</span> <span class="o">=</span> <span class="n">stddf</span><span class="p">,</span>
                         <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="p">,</span>
                         <span class="n">tzstr</span><span class="o">=</span><span class="n">tzstring</span><span class="p">,</span>
                         <span class="n">plot_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s1">&#39;plot_settings&#39;</span><span class="p">][</span><span class="s1">&#39;diurnal&#39;</span><span class="p">],</span>
                         <span class="n">colorby</span> <span class="o">=</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span>
                         <span class="n">lcz_dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
                         <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                         <span class="n">y_label</span> <span class="o">=</span> <span class="n">y_label</span><span class="p">,</span>
                         <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hourly_avg</span><span class="p">,</span> <span class="n">stats</span>

        <span class="k">return</span> <span class="n">hourly_avg</span></div>

    <span class="c1"># =============================================================================</span>
    <span class="c1"># Correlations analysis</span>
    <span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="Analysis.get_lc_correlation_matrices"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.get_lc_correlation_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">get_lc_correlation_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;temp&#39;</span><span class="p">],</span> <span class="n">groupby_labels</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A method to compute the Pearson correlation between an obervation type</span>
<span class="sd">        and present landcover fractions in the metadf.</span>

<span class="sd">        The correlations are computed per group as defined by unique combinations</span>
<span class="sd">        of the groupby_labels.</span>

<span class="sd">        A dictionary is returnd where each key represents a unique combination of</span>
<span class="sd">        the groupby_labels. The value is a dictionary with the following keys</span>
<span class="sd">        and values:</span>
<span class="sd">        * cor matrix: the Pearson correlation matrix</span>
<span class="sd">        * significance matrix: the significance (p-)values of the correlations.</span>
<span class="sd">        * combined matrix: A human readable combination of the correlations and their p values. Indicate by *, ** or *** representing p-values &lt; 0.05, 0.01 and 0.001 respectively.</span>

<span class="sd">        This dictionary is also stored as a lc_cor_dict attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        obstype : str, or list optional</span>
<span class="sd">            The observation type(s) to compute the correlations on. The default is [&#39;temp&#39;].</span>
<span class="sd">        groupby_labels : list, optional</span>
<span class="sd">            List of variables to form one group, resulting in one correlation.</span>
<span class="sd">            These variables should either a categorical observation type, a categorical column in the metadf or</span>
<span class="sd">            a time aggregation. All possible time aggreagetions are: [&#39;minute&#39;,</span>
<span class="sd">            &#39;hour&#39;, &#39;month&#39;, &#39;year&#39;, &#39;day_of_year&#39;,</span>
<span class="sd">            &#39;week_of_year&#39;, &#39;season&#39;]. The default is [&#39;lcz&#39;, &#39;datetime&#39;].. The default is [&#39;hour&#39;].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cor_dict : dict</span>
<span class="sd">            A nested dictionary with unique combinations of groupby values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obstype</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">obstype</span> <span class="o">=</span> <span class="p">[</span><span class="n">obstype</span><span class="p">]</span>

        <span class="c1"># get data</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">_make_time_derivatives</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">groupby_labels</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">group_lab</span> <span class="ow">in</span> <span class="n">groupby_labels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_lab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[[</span><span class="n">group_lab</span><span class="p">]],</span>
                              <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span>
                              <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span>
                              <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">group_lab</span> <span class="ow">in</span> <span class="n">groupby_labels</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">group_lab</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">group_lab</span><span class="si">}</span><span class="s1">&quot; is found in the observations of possible groupby_labels.&#39;</span>


        <span class="c1"># subset columns</span>
        <span class="n">relev_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">groupby_labels</span><span class="p">]</span> <span class="c1">#to avoid deep copy import</span>
        <span class="n">relev_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
        <span class="n">relev_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obstype</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">relev_columns</span><span class="p">]</span>

        <span class="c1"># find landcover columnnames in the metadf</span>
        <span class="n">lc_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="p">((</span><span class="s1">&#39;_&#39;</span> <span class="ow">in</span> <span class="n">col</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;m&#39;</span><span class="p">)))]</span>

        <span class="c1"># get landcover data</span>
        <span class="n">lc_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="n">lc_columns</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">lc_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: No landcover columns found in the metadf. Landcover correlations cannot be computed.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>


        <span class="c1"># merge together</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">lc_df</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">right_index</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># remove name column if it is not explicit in the groupby labels</span>
        <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groupby_labels</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>



        <span class="c1"># create return</span>
        <span class="n">cor_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#Iterate over all groups</span>

        <span class="c1"># avoid futur pandas warning for groupby labels of len==1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groupby_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">groupby_labels</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">group_lab</span><span class="p">,</span> <span class="n">groupdf</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="c1"># No correlations can be computed when no variance is found</span>
            <span class="k">if</span> <span class="n">groupdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No variance found in correlationd group </span><span class="si">{</span><span class="n">group_lab</span><span class="si">}</span><span class="s1">. Correlation thus not be computed for this group: </span><span class="si">{</span><span class="n">groupdf</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># drop groupby labels</span>
            <span class="n">groupdf</span> <span class="o">=</span> <span class="n">groupdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">groupby_labels</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

            <span class="n">rho</span> <span class="o">=</span> <span class="n">groupdf</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;pearson&#39;</span><span class="p">)</span>
            <span class="n">pval</span> <span class="o">=</span> <span class="n">groupdf</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">pearsonr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">rho</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># represent p values by stars</span>
            <span class="n">p_stars</span> <span class="o">=</span> <span class="n">pval</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;*&#39;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">.05</span><span class="p">,</span> <span class="mf">.01</span><span class="p">,</span> <span class="mf">.001</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">t</span><span class="p">]))</span>

            <span class="c1"># combined human readable df</span>
            <span class="n">comb_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">rho</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">rho</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">comb_df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="si">:</span><span class="s2">.02f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">p_stars</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

            <span class="n">cor_dict</span><span class="p">[</span><span class="n">group_lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cor matrix&#39;</span><span class="p">:</span> <span class="n">rho</span><span class="p">,</span>
                                   <span class="s1">&#39;significance matrix&#39;</span><span class="p">:</span> <span class="n">pval</span><span class="p">,</span>
                                   <span class="s1">&#39;combined matrix&#39;</span><span class="p">:</span> <span class="n">comb_df</span><span class="p">}</span>


        <span class="c1"># Update attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span> <span class="o">=</span> <span class="n">cor_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lc_cor_obstype</span> <span class="o">=</span> <span class="n">obstype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span> <span class="o">=</span> <span class="n">groupby_labels</span>

        <span class="k">return</span> <span class="n">cor_dict</span></div>


<div class="viewcode-block" id="Analysis.plot_correlation_heatmap"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.plot_correlation_heatmap">[docs]</a>    <span class="k">def</span> <span class="nf">plot_correlation_heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupby_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a heatmap plot af a correaltion matrix. To specify which correlation</span>
<span class="sd">        matrix to plot, specify the group value using the groupby_value argument.</span>

<span class="sd">        All possible groupby_values are the keys of the lc_cor_dict attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        groupby_value : str, num, None, optional</span>
<span class="sd">            A groupby value to indicate which correlation matrix to visualise.</span>
<span class="sd">            If None is given, the first groupby value that is present is</span>
<span class="sd">            chosen.The default is None.</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title of the figure. If None, a default title is constructed.The</span>
<span class="sd">            default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        To list all possible groupby_values, one can use</span>
<span class="sd">        ` print(Analysis_instance.lc_cor_dict.keys())`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if there are correlation matrices</span>
        <span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="p">),</span> <span class="s1">&#39;No correlation matrices found, use the metod get_lc_correlation_matrices first.&#39;</span>

        <span class="k">if</span> <span class="n">groupby_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">groupby_value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: No groupby_value is given, so the first groupby value (=</span><span class="si">{groupby_value}</span><span class="s1">) will be used!&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;INFO: The correlations are computed over </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span><span class="si">}</span><span class="s1"> with the following unique values: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># check if groupby value exists</span>
        <span class="k">assert</span> <span class="n">groupby_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">groupby_value</span><span class="si">}</span><span class="s1"> not found as a groupby value. These are all the possible values: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span>


        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Correlation heatmap for group: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">groupby_value</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">heatmap_plot</span><span class="p">(</span><span class="n">cor_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="p">[</span><span class="n">groupby_value</span><span class="p">],</span>
                     <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                     <span class="n">heatmap_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s1">&#39;plot_settings&#39;</span><span class="p">][</span><span class="s1">&#39;correlation_heatmap&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Analysis.plot_correlation_variation"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.Analysis.html#metobs_toolkit.analysis.Analysis.plot_correlation_variation">[docs]</a>    <span class="k">def</span> <span class="nf">plot_correlation_variation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a scatter plot of the correlations to visualise differences between</span>
<span class="sd">        multiple group values.</span>

<span class="sd">        Group values are represented by the horizontal axes, and correlations</span>
<span class="sd">        on the vertical axe.</span>

<span class="sd">        All correlations, that are not constant, are plotted as scatters with</span>
<span class="sd">        unique colors.</span>

<span class="sd">        The scatter marker indicates the p-value of the correlations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        title : str, optional</span>
<span class="sd">            Title of the figure. If None, a default title is constructed. The</span>
<span class="sd">            default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        If to many possible group values exist, one can use the apply_filter()</span>
<span class="sd">        method to reduce the group values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check if there are correlation matrices</span>
        <span class="k">assert</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="p">),</span> <span class="s1">&#39;No correlation matrices found, use the metod get_lc_correlation_matrices first.&#39;</span>

        <span class="c1"># check if correlation evolution information is available</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;WARNING: Only one correlation group is found: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The variance plot can not be made.&#39;</span><span class="p">)</span>
            <span class="k">return</span>



        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Correlation scatter for group: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span><span class="si">}</span><span class="s1">&#39;</span>


        <span class="n">correlation_scatter</span><span class="p">(</span><span class="n">full_cor_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lc_cor_dict</span><span class="p">,</span>
                            <span class="n">groupby_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lc_groupby_labels</span><span class="p">,</span>
                            <span class="n">obstypes</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_lc_cor_obstype</span><span class="p">,</span>
                            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                            <span class="n">cor_scatter_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s1">&#39;plot_settings&#39;</span><span class="p">][</span><span class="s1">&#39;correlation_scatter&#39;</span><span class="p">])</span></div></div>



<span class="k">def</span> <span class="nf">_make_time_derivatives</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">required</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; construct time derivated columns if required.</span>
<span class="sd">        datetime must be a column.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;minute&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;minute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;hour&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;hour&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;month&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;month&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">month_name</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;year&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;day_of_year&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day_of_year</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;week_of_year&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;week_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">isocalendar</span><span class="p">()[</span><span class="s1">&#39;week&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;season&#39;</span> <span class="ow">in</span> <span class="n">required</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">get_all</span><span class="p">):</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;season&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_seasons</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;datetime&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">df</span>



<div class="viewcode-block" id="get_seasons"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.get_seasons.html#metobs_toolkit.analysis.get_seasons">[docs]</a><span class="k">def</span> <span class="nf">get_seasons</span><span class="p">(</span><span class="n">datetimeseries</span><span class="p">,</span>
                <span class="n">start_day_spring</span> <span class="o">=</span> <span class="s1">&#39;01/03&#39;</span> <span class="p">,</span>
                <span class="n">start_day_summer</span> <span class="o">=</span> <span class="s1">&#39;01/06&#39;</span><span class="p">,</span>
                <span class="n">start_day_autumn</span> <span class="o">=</span> <span class="s1">&#39;01/09&#39;</span><span class="p">,</span>
                <span class="n">start_day_winter</span> <span class="o">=</span> <span class="s1">&#39;01/12&#39;</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot; Convert a datetimeseries to a season label (i.g. categorical). &quot;&quot;&quot;</span>


    <span class="n">spring_startday</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_day_spring</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">/%m&#39;</span><span class="p">)</span>
    <span class="n">summer_startday</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_day_summer</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">/%m&#39;</span><span class="p">)</span>
    <span class="n">autumn_startday</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_day_autumn</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">/%m&#39;</span><span class="p">)</span>
    <span class="n">winter_startday</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_day_winter</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">/%m&#39;</span><span class="p">)</span>


    <span class="n">seasons</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;spring&#39;</span><span class="p">,</span> <span class="s1">&#39;summer&#39;</span><span class="p">,</span> <span class="s1">&#39;autumn&#39;</span><span class="p">,</span> <span class="s1">&#39;winter&#39;</span><span class="p">],</span>
                        <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">spring_startday</span><span class="p">,</span> <span class="n">summer_startday</span><span class="p">,</span> <span class="n">autumn_startday</span><span class="p">,</span> <span class="n">winter_startday</span><span class="p">],</span>
                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;startdt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
    <span class="n">seasons</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seasons</span><span class="p">[</span><span class="s1">&#39;startdt&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day_of_year</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">bins</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">seasons</span><span class="p">[</span><span class="s1">&#39;day_of_year&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_list</span><span class="p">())</span>
    <span class="n">bins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">366</span><span class="p">)</span>

    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;winter&#39;</span><span class="p">,</span> <span class="s1">&#39;spring&#39;</span><span class="p">,</span> <span class="s1">&#39;summer&#39;</span><span class="p">,</span> <span class="s1">&#39;autumn&#39;</span><span class="p">,</span> <span class="s1">&#39;winter&#39;</span><span class="p">]</span>



    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">datetimeseries</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day_of_year</span><span class="p">,</span>
                  <span class="n">bins</span> <span class="o">=</span> <span class="n">bins</span><span class="p">,</span>
                  <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
                  <span class="n">ordered</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="p">)</span></div>







<div class="viewcode-block" id="filter_data"><a class="viewcode-back" href="../../_autosummary/metobs_toolkit.analysis.filter_data.html#metobs_toolkit.analysis.filter_data">[docs]</a><span class="k">def</span> <span class="nf">filter_data</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">metadf</span><span class="p">,</span> <span class="n">quarry_str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to filter a dataframe by a user definde string expression. This</span>
<span class="sd">    can be used to filter the observation to specific meteorological conditions</span>
<span class="sd">    (i.e. low windspeeds, high humidity, cold temperatures, ...)</span>

<span class="sd">    The filter expression contains only columns present in the df and/or the</span>
<span class="sd">    metadf.</span>

<span class="sd">    The filtered df and metadf are returned</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    df : pandas.DataFrame</span>
<span class="sd">        The dataframe containing all the observations to be filterd.</span>
<span class="sd">    metadf : pandas.DataFrame</span>
<span class="sd">        The dataframe containig all the metadata per station.</span>
<span class="sd">    quarry_str : str</span>
<span class="sd">        A filter expression using columnnames present in either df or metadf.</span>
<span class="sd">        The following timestamp derivatives can be used as well: [minute, hour,</span>
<span class="sd">        month, year, day_of_year, week_of_year, season]. The quarry_str may</span>
<span class="sd">        contain number and expressions like &lt;, &gt;, ==, &gt;=, *, +, .... Multiple filters</span>
<span class="sd">        can be combine to one expression by using &amp; (AND) and | (OR).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    filter_df : pandas.DataFrame</span>
<span class="sd">        The filtered df.</span>
<span class="sd">    filter_metadf : pandas.DataFrame</span>
<span class="sd">        The filtered metadf.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1"># save index order and names for reconstruction</span>
    <span class="n">df_init_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
    <span class="n">metadf_init_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="c1"># easyer for sperationg them</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
    <span class="n">metadf</span> <span class="o">=</span> <span class="n">metadf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

    <span class="c1"># save columns orders</span>
    <span class="n">df_init_cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">metadf_init_cols</span> <span class="o">=</span> <span class="n">metadf</span><span class="o">.</span><span class="n">columns</span>


    <span class="c1"># create time derivative columns</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">_make_time_derivatives</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">get_all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># merge together on name</span>
    <span class="n">mergedf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">metadf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>

    <span class="c1">#apply filter</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="o">=</span><span class="n">quarry_str</span><span class="p">)</span>

    <span class="c1"># split to df and metadf</span>
    <span class="n">filter_df</span> <span class="o">=</span> <span class="n">filtered</span><span class="p">[</span><span class="n">df_init_cols</span><span class="p">]</span>
    <span class="n">filter_metadf</span> <span class="o">=</span> <span class="n">filtered</span><span class="p">[</span><span class="n">metadf_init_cols</span><span class="p">]</span>

    <span class="c1"># set indexes</span>
    <span class="n">filter_df</span> <span class="o">=</span> <span class="n">filter_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df_init_idx</span><span class="p">)</span>
    <span class="n">filter_metadf</span> <span class="o">=</span> <span class="n">filter_metadf</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">metadf_init_idx</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">filter_df</span><span class="p">,</span> <span class="n">filter_metadf</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Thomas Vergauwen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-XXXXXXXXXX', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>